{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"supabase-realtime-client # Python Client Library to interface with the Phoenix Realtime Server Note This is a fork of the Supabase Community Realtime Client I am maintaining this fork with my changes for another project, that will use this under the hood.","title":"Home"},{"location":"#supabase-realtime-client","text":"Python Client Library to interface with the Phoenix Realtime Server Note This is a fork of the Supabase Community Realtime Client I am maintaining this fork with my changes for another project, that will use this under the hood.","title":"supabase-realtime-client"},{"location":"quickstart/","text":"Quick Start # import asyncio from realtime import Socket def callback1 ( payload ): print ( \"Callback 1: \" , payload ) def callback2 ( payload ): print ( \"Callback 2: \" , payload ) async def main () -> None : URL = \"ws://localhost:4000/socket/websocket\" s = Socket ( URL ) await s . connect () # join channels channel_1 = s . set_channel ( \"realtime:public:todos\" ) await channel_1 . join () channel_2 = s . set_channel ( \"realtime:public:users\" ) await channel_2 . join () # register callbacks channel_1 . on ( \"UPDATE\" , callback1 ) channel_2 . on ( \"*\" , callback2 ) await s . listen () # infinite loop Sample usage with Supabase # Here's how you could connect to your realtime endpoint using Supabase endpoint. Please replace SUPABASE_ID and API_KEY with your own SUPABASE_ID and API_KEY . The variables shown below are fake and they will not work if you try to run the snippet. import asyncio from realtime import Socket SUPABASE_ID = \"dlzlllxhaakqdmaapvji\" API_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW5vbiIsImlhdCI6MT\" def callback1 ( payload ): print ( \"Callback 1: \" , payload ) async def main () -> None : URL = f \"wss:// { SUPABASE_ID } .supabase.co/realtime/v1/websocket?apikey= { API_KEY } &vsn=1.0.0\" s = Socket ( URL ) await s . connect () channel_1 = s . set_channel ( \"realtime:*\" ) await channel_1 . join () channel_1 . on ( \"UPDATE\" , callback1 ) await s . listen () Then, go to the Supabase interface and toggle a row in a table. You should see a corresponding payload show up in your console/terminal.","title":"Quickstart"},{"location":"quickstart/#quick-start","text":"import asyncio from realtime import Socket def callback1 ( payload ): print ( \"Callback 1: \" , payload ) def callback2 ( payload ): print ( \"Callback 2: \" , payload ) async def main () -> None : URL = \"ws://localhost:4000/socket/websocket\" s = Socket ( URL ) await s . connect () # join channels channel_1 = s . set_channel ( \"realtime:public:todos\" ) await channel_1 . join () channel_2 = s . set_channel ( \"realtime:public:users\" ) await channel_2 . join () # register callbacks channel_1 . on ( \"UPDATE\" , callback1 ) channel_2 . on ( \"*\" , callback2 ) await s . listen () # infinite loop","title":"Quick Start"},{"location":"quickstart/#sample-usage-with-supabase","text":"Here's how you could connect to your realtime endpoint using Supabase endpoint. Please replace SUPABASE_ID and API_KEY with your own SUPABASE_ID and API_KEY . The variables shown below are fake and they will not work if you try to run the snippet. import asyncio from realtime import Socket SUPABASE_ID = \"dlzlllxhaakqdmaapvji\" API_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW5vbiIsImlhdCI6MT\" def callback1 ( payload ): print ( \"Callback 1: \" , payload ) async def main () -> None : URL = f \"wss:// { SUPABASE_ID } .supabase.co/realtime/v1/websocket?apikey= { API_KEY } &vsn=1.0.0\" s = Socket ( URL ) await s . connect () channel_1 = s . set_channel ( \"realtime:*\" ) await channel_1 . join () channel_1 . on ( \"UPDATE\" , callback1 ) await s . listen () Then, go to the Supabase interface and toggle a row in a table. You should see a corresponding payload show up in your console/terminal.","title":"Sample usage with Supabase"},{"location":"reference/channel/","text":"Channel # realtime.channel.Channel # Channel is an abstraction for a topic listener for an existing socket connection. Each Channel has its own topic and a list of event-callbacks that responds to messages. Should only be instantiated through connection.Socket().set_chanel(topic) Topic-Channel has a 1-many relationship. __init__ ( self , socket , topic , params = {}) special # Parameters: Name Type Description Default socket Socket Socket object required topic str Topic to subcribe to on the realtime server required params dict {} join ( self ) async # Attempt to join Phoenix Realtime server for a certain topic. on ( self , event , callback ) # Parameters: Name Type Description Default event str A specific event will have a specific callback required callback Callable[[Any], Any] Callback that takes msg payload as its first argument required Returns: Type Description Channel Channel off ( self , event ) # Stop listening to a particular event. Parameters: Name Type Description Default event str event to stop responding to required","title":"Channel"},{"location":"reference/channel/#channel","text":"","title":"Channel"},{"location":"reference/channel/#realtime.channel.Channel","text":"Channel is an abstraction for a topic listener for an existing socket connection. Each Channel has its own topic and a list of event-callbacks that responds to messages. Should only be instantiated through connection.Socket().set_chanel(topic) Topic-Channel has a 1-many relationship.","title":"Channel"},{"location":"reference/channel/#realtime.channel.Channel.__init__","text":"Parameters: Name Type Description Default socket Socket Socket object required topic str Topic to subcribe to on the realtime server required params dict {}","title":"__init__()"},{"location":"reference/channel/#realtime.channel.Channel.join","text":"Attempt to join Phoenix Realtime server for a certain topic.","title":"join()"},{"location":"reference/channel/#realtime.channel.Channel.on","text":"Parameters: Name Type Description Default event str A specific event will have a specific callback required callback Callable[[Any], Any] Callback that takes msg payload as its first argument required Returns: Type Description Channel Channel","title":"on()"},{"location":"reference/channel/#realtime.channel.Channel.off","text":"Stop listening to a particular event. Parameters: Name Type Description Default event str event to stop responding to required","title":"off()"},{"location":"reference/connection/","text":"Connection # realtime.connection.Socket # __init__ ( self , url , params = {}, hb_interval = 5 ) special # Socket is the abstraction for an actual socket connection that receives and 'reroutes' Message according to its topic and event . Socket-Channel has a 1-many relationship. Socket-Topic has a 1-many relationship. Parameters: Name Type Description Default url str Websocket URL of the Realtime server. starts with ws:// or wss:// required params dict Optional parameters for connection. {} hb_interval int WS connection is kept alive by sending a heartbeat message every few seconds. 5 connect ( self ) async # Connect to the realtime server. set_channel ( self , topic ) # Parameters: Name Type Description Default topic str Initializes a channel and creates a two-way association with the socket required Returns: Type Description Channel Channel listen ( self ) async # An infinite loop that keeps listening. This method should be called last. summary ( self ) # Gets the list of sockets and events being listened for.","title":"Connection"},{"location":"reference/connection/#connection","text":"","title":"Connection"},{"location":"reference/connection/#realtime.connection.Socket","text":"","title":"Socket"},{"location":"reference/connection/#realtime.connection.Socket.__init__","text":"Socket is the abstraction for an actual socket connection that receives and 'reroutes' Message according to its topic and event . Socket-Channel has a 1-many relationship. Socket-Topic has a 1-many relationship. Parameters: Name Type Description Default url str Websocket URL of the Realtime server. starts with ws:// or wss:// required params dict Optional parameters for connection. {} hb_interval int WS connection is kept alive by sending a heartbeat message every few seconds. 5","title":"__init__()"},{"location":"reference/connection/#realtime.connection.Socket.connect","text":"Connect to the realtime server.","title":"connect()"},{"location":"reference/connection/#realtime.connection.Socket.set_channel","text":"Parameters: Name Type Description Default topic str Initializes a channel and creates a two-way association with the socket required Returns: Type Description Channel Channel","title":"set_channel()"},{"location":"reference/connection/#realtime.connection.Socket.listen","text":"An infinite loop that keeps listening. This method should be called last.","title":"listen()"},{"location":"reference/connection/#realtime.connection.Socket.summary","text":"Gets the list of sockets and events being listened for.","title":"summary()"},{"location":"reference/exceptions/","text":"Exceptions # realtime.exceptions.NotConnectedError ( RealtimeError ) # Raised when operations requiring a connection are executed when socket is not connected realtime.exceptions.ConnectionFailedError ( RealtimeError ) # Raised when connecting to the Phoenix server fails.","title":"Exceptions"},{"location":"reference/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"reference/exceptions/#realtime.exceptions.NotConnectedError","text":"Raised when operations requiring a connection are executed when socket is not connected","title":"NotConnectedError"},{"location":"reference/exceptions/#realtime.exceptions.ConnectionFailedError","text":"Raised when connecting to the Phoenix server fails.","title":"ConnectionFailedError"},{"location":"reference/message/","text":"","title":"Message"}]}